// http://www.gamers.org/dEngine/quake/spec/quake-spec34/index2.htm
// https://gitlab.com/xonotic/xonotic/wikis/Introduction_to_QuakeC
// Based on: https://github.com/JetBrains/Grammar-Kit/blob/master/testData/generator/ExprParser.bnf
// TODO: generate sensible parse tree
// TODO: macro expansion
// TODO: string continuation (escape, gap)
// TODO: https://devnet.jetbrains.com/thread/449622?tstart=330
{
    parserClass             = "com.timepath.quakec.parser.QCParser"
    parserUtilClass         = "com.timepath.quakec.parser.QCParserUtil"

    extends                 = "com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix          = "QC"
    psiImplClassSuffix      = "Impl"
    psiPackage              = "com.timepath.quakec.psi"
    psiImplPackage          = "com.timepath.quakec.psi.impl"

    elementTypeHolderClass  = "com.timepath.quakec.psi.QCTypes"
    elementTypeClass        = "com.timepath.quakec.psi.QCElementType"
    tokenTypeClass          = "com.timepath.quakec.psi.QCTokenType"

    tokens = [
        OP_ASSIGN='='
        OP_ADDA='+='
        OP_SUBA='-='
        OP_MULA='*='
        OP_DIVA='/='
        OP_MODA='%='
        OP_ANDA='&='
        OP_ORA='|='
        OP_XORA='^='
        OP_LSHA='<<='
        OP_RSHA='>>='

        OP_OR_LOGIC='||'
        OP_AND_LOGIC='&&'
        OP_NOT_LOGIC='!'

        OP_OR='|'
        OP_XOR='^'
        OP_AND='&'
        OP_NOT='~'

        OP_EQ='=='
        OP_NE='!='
        OP_LT='<'
        OP_LE='<='
        OP_GT='>'
        OP_GE='>='
        OP_LSH='<<'
        OP_RSH='>>'

        OP_PLUS='+'
        OP_MINUS='-'
        OP_MULTIPLY='*'
        OP_DIVIDE='/'
        OP_MODULO='%'

        OP_INC='++'
        OP_SUB='--'
        OP_COMMA=','
        OP_DOT='.'

        SEMI=';'
        COLON=':'
        QUESTION='?'
        HASH='#'

        BRACE_OPEN='{'
        BRACE_CLOSE='}'
        INDEX_OPEN='['
        INDEX_CLOSE=']'
        PAREN_OPEN='('
        PAREN_CLOSE=')'

        T_ENTITY='entity'
        T_STRING='string'
        T_VECTOR='vector'
        T_FLOAT='float'
        T_VOID='void'
        T_ARGS='...'

        MOD_LOCAL='local'
        MOD_CONST='const'
        MOD_VAR='var'
        MOD_NOREF='noref'

        KW_CONTINUE='continue'
        KW_BREAK='break'
        KW_GOTO='goto'
        KW_RETURN='return'
        KW_IF='if'
        KW_NOT='not'
        KW_ELSE='else'
        KW_WHILE='while'
        KW_DO='do'
        KW_FOR='for'
        KW_SWITCH='switch'
        KW_CASE='case'
        KS_DEFAULT='default'
        KS_TYPEDEF='typedef'

        space               = 'regexp:\s+'
        preprocessor        = 'regexp:#\s*(define|include|(un|ifn?)def|endif|el(if|se)|if|warning|error|pragma)(.*\\\s*\n)*.*'
        comment_line        = 'regexp://.*'
        comment_block       = 'regexp:[\/][*](([^*]+|[*]+[^\/*])*[*]*)[*][\/]'
        number              = 'regexp:0x[_0-9a-fA-F]+|[_0-9]*(\.[_0-9]*)?'
        string              = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
        id                  = 'regexp:[a-zA-Z_][a-zA-Z_0-9]*'
    ]
    extends("expr_.+")      = expression
    extends("stat_.+")      = statement
}

root                        ::= (root_item)*
private root_item           ::= !(<<eof>>) scope_root {pin=1}
comment                     ::= (preprocessor | comment_line | comment_block)
private s                   ::= (space? comment)+ space? | space
private scope_common        ::= var | s | ';'
private scope_root          ::= func | scope_common
private scope_block         ::= statement | scope_common

identifier                  ::= id | type_modifier_
builtin                     ::= '#' number
literal                     ::= number | string

private type_modifier_      ::= 'local' | 'const' | 'noref'
type_modifier               ::= type_modifier_
type_name                   ::= 'void' | 'float' | 'vector' | 'string' | 'entity' | identifier

type_arg                    ::= type (s? type_func)? (s? identifier (s? '=' s? expression)?)?
type_args                   ::= '...' | type_arg? (s? ',' s? type_arg)* (s? ',' s? ('...' | type_arg))?
private type_func           ::= '(' s? type_args s? ')'
private type                ::= (type_modifier s?)* '.'? type_name

block_switch                ::= '{' s? (stat_switch_body s?)* '}'
block                       ::= '{' s? scope_block* s? '}'

var_entry                   ::= identifier ('[' expression ']')? (s? '=' s? expression)?
var_list                    ::= var_entry (s? ',' s? var_entry)*
var_normal                  ::= type s? var_list s? ';'
var_func                    ::= var_func_
private var_func_           ::= type s? type_func s? identifier s? ('=' s? identifier s?)? ';'
var_typedef                 ::= 'typedef' s? type s? (type_func s?)? identifier s? ';'
var                         ::= ('var' s?)? (var_normal | var_func | var_typedef)

private func_old            ::= type s? type_func s? identifier s? (';' | '=' s? (builtin s? ';' | block (s? ';')?))?
private func_new            ::= type s? identifier s? type_func s? ('=' s? builtin | block | ';')
func                        ::= var_func_ | func_old | func_new

statement                   ::= stat_label
                            | stat_block
                            | stat_select
                            | stat_iter
                            | stat_jump
                            | stat_expr

private stat_block          ::= block s?
stat_expr                   ::= expression? s? ';' s?

stat_label                  ::= ':' identifier s? statement
stat_case                   ::= ('case' s? expression | 'default') s? ':'
stat_jump                   ::= ('continue' (s? identifier)? | 'break' (s? identifier)? | 'goto' (s? identifier) | 'return' (s? expression)?) s? ';' s?
private stat_select         ::= stat_if
                            | stat_switch
stat_if                     ::= 'if' s? ('not' s?)? '(' s? expression s? ')' s? statement s? ('else' s? statement)?
stat_case_body              ::= block | scope_block*
stat_switch_body            ::= (stat_case s? stat_case_body)+
stat_switch                 ::= 'switch' s? '(' s? expression s? ')' s? block_switch
private stat_while          ::= 'while' s? '(' s? expression s? ')'
stat_while_do               ::= stat_while s? statement
stat_do_while               ::= 'do' s? statement s? stat_while s? ';' s?
stat_for                    ::= 'for' s? '(' s? expression? s? ';' s? expression? s? ';' s? expression? s? ')' s? statement
stat_iter                   ::= stat_while_do
                            | stat_do_while
                            | stat_for

// http://en.wikipedia.org/wiki/Order_of_operations#Programming_languages
// weak -> strong : split first -> last
expression                  ::= (expr_comma | expr_assign | expr_const)
private expr_const          ::= expr_elvis
                            | expr_or
                            | expr_and
                            | expr_or_bit
                            | expr_xor
                            | expr_and_bit
                            | expr_eq
                            | expr_cmp
                            | expr_shift
                            | expr_add
                            | expr_fac
                            | group_unary
                            | group_access
                            | group_primary

private op_comma            ::= ','
private op_assign           ::= ('=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=')
private op_eq               ::= ('==' | '!=')
private op_cmp              ::= ('<' | '<=' | '>' | '>=')
private op_shift            ::= ('<<' | '>>')
private op_add              ::= ('+' | '-')
private op_fac              ::= ('*' | '/' | '%')
private op_unary            ::= ('!' | '~' | '-' | '+')
private op_inc              ::= ('++' | '--')

expr_comma                  ::= expression s? op_comma s? expression
expr_assign                 ::= expression s? op_assign s? expression {rightAssociative=true}
expr_elvis                  ::= expression s? '?' (s? expr_elvis s? ':' s? expr_elvis)
expr_or                     ::= expression s? '||' s? expression
expr_and                    ::= expression s? '&&' s? expression
expr_or_bit                 ::= expression s? '|' s? expression
expr_xor                    ::= expression s? '^' s? expression
expr_and_bit                ::= expression s? '&' s? expression
expr_eq                     ::= expression s? op_eq s? expression
expr_cmp                    ::= expression s? op_cmp s? expression
expr_shift                  ::= expression s? op_shift s? expression
expr_add                    ::= expression s? op_add s? expression
expr_fac                    ::= expression s? op_fac s? expression
private group_unary         ::= expr_unary_pre
                            | expr_unary_post
expr_unary_pre              ::= (op_unary | op_inc) s? expression
expr_unary_post             ::= expression s? op_inc
private group_access        ::= expr_call
                            | expr_index
                            | expr_ref
expr_ref                    ::= expression s? '.' s? ('(' s? expression s? ')' | expression)
arg_list                    ::= expression (s? ',' s? expression)*
expr_call                   ::= expression s? '(' s? arg_list? s? ')'
expr_index                  ::= expression s? '[' s? (expression) s? ']'
private group_primary       ::= expr_i18n
                            | expr_simple_ref
                            | expr_literal
                            | expr_paren
expr_simple_ref             ::= identifier {elementType=expr_ref}
expr_literal                ::= literal
expr_paren                  ::= '(' s? expression s? ')'

expr_i18n                   ::= '_' s? '(' (s? string)* s? ')'
