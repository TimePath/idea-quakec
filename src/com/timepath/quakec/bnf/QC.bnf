// http://www.gamers.org/dEngine/quake/spec/quake-spec34/index2.htm
// Based on: https://github.com/JetBrains/Grammar-Kit/blob/master/testData/generator/ExprParser.bnf
// TODO: switch/case scope
// TODO: generate sensible parse tree
// TODO: macro expansion
// TODO: string continuation (escape, gap)
// TODO: https://devnet.jetbrains.com/thread/449622?tstart=330
{
    parserClass             = "com.timepath.quakec.parser.QCParser"
    parserUtilClass         = "com.timepath.quakec.parser.QCParserUtil"

    extends                 = "com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix          = "QC"
    psiImplClassSuffix      = "Impl"
    psiPackage              = "com.timepath.quakec.psi"
    psiImplPackage          = "com.timepath.quakec.psi.impl"

    elementTypeHolderClass  = "com.timepath.quakec.psi.QCTypes"
    elementTypeClass        = "com.timepath.quakec.psi.QCElementType"
    tokenTypeClass          = "com.timepath.quakec.psi.QCTokenType"

    tokens = [
        OP_ASSIGN='='
        OP_ADDA='+='
        OP_SUBA='-='
        OP_MULA='*='
        OP_DIVA='/='
        OP_MODA='%='
        OP_ANDA='&='
        OP_ORA='|='
        OP_XORA='^='
        OP_LSHA='<<='
        OP_RSHA='>>='

        OP_OR_LOGIC='||'
        OP_AND_LOGIC='&&'
        OP_NOT_LOGIC='!'

        OP_OR='|'
        OP_XOR='^'
        OP_AND='&'
        OP_NOT='~'

        OP_EQ='=='
        OP_NE='!='
        OP_LT='<'
        OP_LE='<='
        OP_GT='>'
        OP_GE='>='
        OP_LSH='<<'
        OP_RSH='>>'

        OP_PLUS='+'
        OP_MINUS='-'
        OP_MULTIPLY='*'
        OP_DIVIDE='/'
        OP_MODULO='%'

        OP_INC='++'
        OP_SUB='--'
        OP_COMMA=','
        OP_DOT='.'

        SEMI=';'
        COLON=':'
        QUESTION='?'
        HASH='#'

        BRACE_OPEN='{'
        BRACE_CLOSE='}'
        INDEX_OPEN='['
        INDEX_CLOSE=']'
        PAREN_OPEN='('
        PAREN_CLOSE=')'

        T_ENTITY='entity'
        T_STRING='string'
        T_VECTOR='vector'
        T_FLOAT='float'
        T_VOID='void'
        T_ARGS='...'

        MOD_LOCAL='local'
        MOD_CONST='const'
        MOD_VAR='var'
        MOD_NOREF='noref'

        KW_CONTINUE='continue'
        KW_BREAK='break'
        KW_GOTO='goto'
        KW_RETURN='return'
        KW_IF='if'
        KW_ELSE='else'
        KW_WHILE='while'
        KW_DO='do'
        KW_FOR='for'
        KW_SWITCH='switch'
        KW_CASE='case'
        KS_DEFAULT='default'
        KS_TYPEDEF='typedef'

        space               = 'regexp:\s+'
        preprocessor        = 'regexp:#\s*(define|include|(un|ifn?)def|endif|el(if|se)|if|warning|error|pragma)(.*\\\s*\n)*.*'
        comment_line        = 'regexp://.*'
        comment_block       = 'regexp:[\/][*](([^*]+|[*]+[^\/*])*[*]*)[*][\/]'
        number              = 'regexp:0x[_0-9a-fA-F]+|[_0-9]*(\.[_0-9]*)?'
        string              = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
        id                  = 'regexp:[a-zA-Z_][a-zA-Z_0-9]*'
    ]
    extends("expr_.+")      = expression
    extends("stat_.+")      = statement
}

root                        ::= (root_item)*
private root_item           ::= !(<<eof>>) scope_root {pin=1}
comment                     ::= (preprocessor | comment_line | comment_block)
private x                   ::= (space? comment)+ space? | space
private scope_common        ::= var | x | ';'
private scope_root          ::= func | scope_common
private scope_block         ::= statement | scope_common

identifier                  ::= id | type_modifier_
builtin                     ::= '#' number
literal                     ::= number | string

private type_modifier_      ::= 'local' | 'const' | 'var' | 'noref'
type_modifier               ::= type_modifier_
type_name                   ::= 'void' | 'float' | 'vector' | 'string' | 'entity' | identifier

type_arg                    ::= type (x? type_func)? (x? identifier (x? '=' x? expression)?)?
type_args                   ::= '...' | type_arg? (x? ',' x? type_arg)* (x? ',' x? ('...' | type_arg))?
private type_func           ::= '(' x? type_args x? ')'
private type                ::= (type_modifier x?)* '.'? type_name

private block               ::= '{' x? scope_block* x? '}'

var_entry                   ::= identifier ('[' expression ']')? (x? '=' x? expression)?
var_list                    ::= var_entry (x? ',' x? var_entry)*
var_normal                  ::= type x? var_list x? ';'
var_func                    ::= var_func_
private var_func_           ::= type x? type_func x? identifier x? ('=' x? identifier x?)? ';'
var_typedef                 ::= 'typedef' x? type x? (type_func x?)? identifier x? ';'
var                         ::= var_normal | var_func | var_typedef

private func_old            ::= type x? type_func x? identifier x? (';' | '=' x? (builtin x? ';' | block (x? ';')?))?
private func_new            ::= type x? identifier x? type_func x? ('=' x? builtin | block | ';')
func                        ::= var_func_ | func_old | func_new

statement                   ::= stat_label
                            | stat_block
                            | stat_select
                            | stat_iter
                            | stat_jump
                            | stat_expr

private stat_block          ::= block x?
stat_expr                   ::= expression? x? ';' x?

stat_label                  ::= ':' identifier x? statement
                            | ('case' x? expression | 'default') x? ':' x? /* FIXME: (scope_block)* */ stat_jump
stat_jump                   ::= ('continue' (x? identifier)? | 'break' (x? identifier)? | 'goto' (x? identifier) | 'return' (x? expression)?) x? ';' x?
private stat_select         ::= stat_if
                            | stat_switch
stat_if                     ::= 'if' x? '(' x? expression x? ')' x? statement ('else' x? statement)?
stat_switch                 ::= 'switch' x? '(' x? expression x? ')' x? stat_block
private stat_while          ::= 'while' x? '(' x? expression x? ')'
stat_while_do               ::= stat_while x? statement
stat_do_while               ::= 'do' x? statement x? stat_while x? ';' x?
stat_for                    ::= 'for' x? '(' x? expression? x? ';' x? expression? x? ';' x? expression? x? ')' x? statement
stat_iter                   ::= stat_while_do
                            | stat_do_while
                            | stat_for

// http://en.wikipedia.org/wiki/Order_of_operations#Programming_languages
// weak -> strong : split first -> last
expression                  ::= (expr_comma | expr_assign | expr_const)
private expr_const          ::= expr_elvis
                            | expr_or
                            | expr_and
                            | expr_or_bit
                            | expr_xor
                            | expr_and_bit
                            | expr_eq
                            | expr_cmp
                            | expr_shift
                            | expr_add
                            | expr_fac
                            | group_unary
                            | group_access
                            | group_primary

private op_comma            ::= ','
private op_assign           ::= ('=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=')
private op_eq               ::= ('==' | '!=')
private op_cmp              ::= ('<' | '<=' | '>' | '>=')
private op_shift            ::= ('<<' | '>>')
private op_add              ::= ('+' | '-')
private op_fac              ::= ('*' | '/' | '%')
private op_unary            ::= ('!' | '~' | '-' | '+')
private op_inc              ::= ('++' | '--')

expr_comma                  ::= expression x? op_comma x? expression
expr_assign                 ::= expression x? op_assign x? expression {rightAssociative=true}
expr_elvis                  ::= expression x? '?' (x? expr_elvis x? ':' x? expr_elvis)
expr_or                     ::= expression x? '||' x? expression
expr_and                    ::= expression x? '&&' x? expression
expr_or_bit                 ::= expression x? '|' x? expression
expr_xor                    ::= expression x? '^' x? expression
expr_and_bit                ::= expression x? '&' x? expression
expr_eq                     ::= expression x? op_eq x? expression
expr_cmp                    ::= expression x? op_cmp x? expression
expr_shift                  ::= expression x? op_shift x? expression
expr_add                    ::= expression x? op_add x? expression
expr_fac                    ::= expression x? op_fac x? expression
private group_unary         ::= expr_unary_pre
                            | expr_unary_post
expr_unary_pre              ::= (op_unary | op_inc) x? expression
expr_unary_post             ::= expression x? op_inc
private group_access        ::= expr_call
                            | expr_index
                            | expr_ref
expr_ref                    ::= expression x? '.' x? ('(' x? expression x? ')' | expression)
arg_list                    ::= expression (x? ',' x? expression)*
expr_call                   ::= expression x? '(' x? arg_list? x? ')'
expr_index                  ::= expression x? '[' x? (expression) x? ']'
private group_primary       ::= expr_i18n
                            | expr_simple_ref
                            | expr_literal
                            | expr_paren
expr_simple_ref             ::= identifier {elementType=expr_ref}
expr_literal                ::= literal
expr_paren                  ::= '(' x? expression x? ')'

expr_i18n                   ::= '_' x? '(' (x? string)* x? ')'
