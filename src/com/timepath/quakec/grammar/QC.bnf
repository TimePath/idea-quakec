// http://www.gamers.org/dEngine/quake/spec/quake-spec34/index2.htm
// https://gitlab.com/xonotic/xonotic/wikis/Introduction_to_QuakeC
// Based on: https://github.com/JetBrains/Grammar-Kit/blob/master/testData/generator/ExprParser.bnf
// TODO: generate sensible parse tree
// TODO: macro expansion
// TODO: string continuation (escape, gap)
// TODO: https://devnet.jetbrains.com/thread/449622?tstart=330
{
    parserClass             = "com.timepath.quakec.parser.QCParser"
    parserUtilClass         = "com.timepath.quakec.parser.QCParserUtil"

    extends                 = "com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix          = "QC"
    psiImplClassSuffix      = "Impl"
    psiPackage              = "com.timepath.quakec.psi"
    psiImplPackage          = "com.timepath.quakec.psi.impl"
    psiImplUtilClass        = "com.timepath.quakec.psi.impl.QCPsiImplUtil"


    elementTypeHolderClass  = "com.timepath.quakec.psi.QCTypes"
    elementTypeClass        = "com.timepath.quakec.psi.QCElementType"
    tokenTypeClass          = "com.timepath.quakec.psi.QCTokenType"

    tokens = [
        OP_ASSIGN='='
        OP_ADDA='+='
        OP_SUBA='-='
        OP_MULA='*='
        OP_DIVA='/='
        OP_MODA='%='
        OP_ANDA='&='
        OP_ORA='|='
        OP_XORA='^='
        OP_LSHA='<<='
        OP_RSHA='>>='

        OP_OR_LOGIC='||'
        OP_AND_LOGIC='&&'
        OP_NOT_LOGIC='!'

        OP_OR='|'
        OP_XOR='^'
        OP_AND='&'
        OP_NOT='~'

        OP_EQ='=='
        OP_NE='!='
        OP_LT='<'
        OP_LE='<='
        OP_GT='>'
        OP_GE='>='
        OP_LSH='<<'
        OP_RSH='>>'

        OP_PLUS='+'
        OP_MINUS='-'
        OP_MULTIPLY='*'
        OP_DIVIDE='/'
        OP_MODULO='%'

        OP_INC='++'
        OP_SUB='--'
        OP_COMMA=','
        OP_DOT='.'

        SEMI=';'
        COLON=':'
        QUESTION='?'
        HASH='#'

        BRACE_OPEN='{'
        BRACE_CLOSE='}'
        INDEX_OPEN='['
        INDEX_CLOSE=']'
        PAREN_OPEN='('
        PAREN_CLOSE=')'

        T_ENTITY='entity'
        T_STRING='string'
        T_VECTOR='vector'
        T_FLOAT='float'
        T_VOID='void'
        T_ARGS='...'

        MOD_LOCAL='local'
        MOD_CONST='const'
        MOD_VAR='var'
        MOD_NOREF='noref'

        KW_CONTINUE='continue'
        KW_BREAK='break'
        KW_GOTO='goto'
        KW_RETURN='return'
        KW_IF='if'
        KW_NOT='not'
        KW_ELSE='else'
        KW_WHILE='while'
        KW_DO='do'
        KW_FOR='for'
        KW_SWITCH='switch'
        KW_CASE='case'
        KS_DEFAULT='default'
        KS_TYPEDEF='typedef'

        token_space         = 'regexp:\s+'
        token_preprocessor  = 'regexp:#\s*(define|include|(un|ifn?)def|endif|el(if|se)|if|warning|error|pragma)(.*\\\s*\n)*.*'
        token_comment_line  = 'regexp://.*'
        token_comment_block = 'regexp:[\/][*](([^*]+|[*]+[^\/*])*[*]*)[*][\/]'
        token_number        = 'regexp:0x[_0-9a-fA-F]+|[_0-9]*(\.[_0-9]*)?'
        token_string        = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
        token_identifier    = 'regexp:[a-zA-Z_][a-zA-Z_0-9]*'
    ]
    extends(".+_expression")= expression
    extends(".+_statement") = statement
}

// scopes

root                        ::= (root_item)*
private root_item           ::= !(<<eof>>) scope_root {pin=1}
private scope_common        ::= variable_declaration s? ';' | typedef | s | ';'
private scope_root          ::= method | scope_common
private scope_block         ::= statement | scope_common

block_switch                ::= '{' s? (switch_body_statement s?)* '}'
block                       ::= '{' s? scope_block* s? '}'

// regexps

private space               ::= token_space
private preprocessor        ::= token_preprocessor
private comment_line        ::= token_comment_line
private comment_block       ::= token_comment_block
private number              ::= token_number
private string              ::= token_string
identifier                  ::= token_identifier

// literals

private s                   ::= (space? comment)+ space? | space
comment                     ::= (preprocessor | comment_line | comment_block)
literal                     ::= number | string
builtin_method              ::= '#' number
type_builtin                ::= 'void' | 'float' | 'vector' | 'string' | 'entity'
type                        ::= '.'? (type_builtin | identifier)
modifier                    ::= 'local' | 'const' | 'noref'

// declarations

typedef                     ::= 'typedef' s? type s? (type_func s?)? identifier s? ';'

parameter                   ::= type (s? type_func)? (s? identifier (s? '=' s? expression)?)? {
                                    mixin="com.timepath.quakec.psi.impl.QCNamedElementImpl"
                                    implements="com.timepath.quakec.psi.QCNamedElement"
                                    methods = [
                                        value   = "expression"

                                        getName setName getNameIdentifier
                                    ]
                                }
parameter_list              ::= '...' | parameter? (s? ',' s? parameter)* (s? ',' s? ('...' | parameter))?
private type_func           ::= '(' s? parameter_list s? ')'

variable_modifiers          ::= (modifier s?)*
variable                    ::= identifier ('[' expression ']')? (s? '=' s? expression)? {
                                mixin="com.timepath.quakec.psi.impl.QCNamedElementImpl"
                                implements="com.timepath.quakec.psi.QCNamedElement"
                                methods = [
                                    arraySize   = "expression[0]"
                                    value       = "expression[1]"

                                    getName setName getNameIdentifier
                                ]
                            }
private var_normal          ::= variable (s? ',' s? variable)*
private var_func            ::= type_func s? identifier (s? '=' s? identifier)?
variable_declaration        ::= ('var' s?)? variable_modifiers type s? (var_normal | var_func)

private func_old            ::= type s? type_func s? identifier s? (';' | '=' s? (builtin_method s? ';' | block (s? ';')?))?
private func_new            ::= type s? identifier s? type_func s? ('=' s? builtin_method | block | ';')
method                      ::= var_func | func_old | func_new

// statements

statement                   ::= label_statement
                            | block_statement
                            | select_statement
                            | iter_statement
                            | jump_statement
                            | expr_statement

private block_statement     ::= block s?
expr_statement              ::= expression? s? ';' s?

label_statement             ::= ':' identifier s? statement
case_statement              ::= ('case' s? expression | 'default') s? ':'
jump_statement              ::= ('continue' (s? identifier)? | 'break' (s? identifier)? | 'goto' (s? identifier) | 'return' (s? expression)?) s? ';' s?
private select_statement    ::= if_statement
                            | switch_statement
if_statement                ::= 'if' s? ('not' s?)? '(' s? expression s? ')' s? statement s? ('else' s? statement)?
case_body_statement         ::= block | scope_block*
switch_body_statement       ::= (case_statement s? case_body_statement)+
switch_statement            ::= 'switch' s? '(' s? expression s? ')' s? block_switch {methods=[testE="expression"]}
private while_statement     ::= 'while' s? '(' s? expression s? ')'
while_do_statement          ::= while_statement s? statement {methods=[test="expression"]}
do_while_statement          ::= 'do' s? statement s? while_statement s? ';' s? {methods=[test="expression"]}
private for_statement_expr  ::= comma_expression | expression
for_statement_before        ::= (variable_declaration | for_statement_expr)?
for_statement_test          ::= for_statement_expr?
for_statement_continue      ::= for_statement_expr?
for_statement               ::= 'for' s? '(' s? for_statement_before s? ';' s? for_statement_test s? ';' s? for_statement_continue s? ')' s? statement {
                                methods = [
                                    before  = "for_statement_before"
                                    test    = "for_statement_test"
                                    then    = "statement"
                                    after   = "for_statement_continue"
                                ]
                            }
iter_statement              ::= while_do_statement
                            | do_while_statement
                            | for_statement

// expressions

expression                  ::= assign_expression
                            | elvis_expression
                            | or_expression
                            | and_expression
                            | or_bit_expression
                            | xor_expression
                            | and_bit_expression
                            | eq_expression
                            | cmp_expression
                            | shift_expression
                            | add_expression
                            | fac_expression
                            | group_unary
                            | group_access
                            | group_primary

private op_comma            ::= ','
private op_assign           ::= ('=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=')
private op_eq               ::= ('==' | '!=')
private op_cmp              ::= ('<' | '<=' | '>' | '>=')
private op_shift            ::= ('<<' | '>>')
private op_add              ::= ('+' | '-')
private op_fac              ::= ('*' | '/' | '%')
private op_unary            ::= ('!' | '~' | '-' | '+')
private op_inc              ::= ('++' | '--')

comma_expression            ::= expression s? op_comma s? expression
assign_expression           ::= expression s? op_assign s? expression {rightAssociative=true}
elvis_expression            ::= expression s? '?' (s? elvis_expression s? ':' s? elvis_expression)
or_expression               ::= expression s? '||' s? expression
and_expression              ::= expression s? '&&' s? expression
or_bit_expression           ::= expression s? '|' s? expression
xor_expression              ::= expression s? '^' s? expression
and_bit_expression          ::= expression s? '&' s? expression
eq_expression               ::= expression s? op_eq s? expression
cmp_expression              ::= expression s? op_cmp s? expression
shift_expression            ::= expression s? op_shift s? expression
add_expression              ::= expression s? op_add s? expression
fac_expression              ::= expression s? op_fac s? expression
private group_unary         ::= unary_pre_expression
                            | unary_post_expression
unary_pre_expression        ::= (op_unary | op_inc) s? expression
unary_post_expression       ::= expression s? op_inc
private group_access        ::= call_expression
                            | index_expression
                            | ref_expression
ref_expression              ::= expression s? '.' s? ('(' s? expression s? ')' | expression)
arg_list                    ::= expression (s? ',' s? expression)*
call_expression             ::= expression s? '(' s? arg_list? s? ')'
index_expression            ::= expression s? '[' s? (expression) s? ']'
private group_primary       ::= i18n_expression
                            | simple_ref_expression
                            | literal_expression
                            | paren_expression
simple_ref_expression       ::= identifier {elementType=ref_expression}
literal_expression          ::= literal
paren_expression            ::= '(' s? expression s? ')'

i18n_expression             ::= '_' s? '(' (s? string)* s? ')'
